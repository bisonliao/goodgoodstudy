# 推荐系统读书笔记

推荐系统里的两个参与者：

1. 项，也叫物品，也叫内容，也叫item
2. 用户

评测/关注的指标有：

1. 预测准确度和召回率
2. 用户满意度
3. 对长尾物品的覆盖度
4. 用户感受到的多样性、新颖性、惊喜度等
5. 实时性
6. 健壮性

# 1、利用用户行为数据推荐

## 1.1、协同过滤算法

两类协同过滤算法推荐系统：

1. 基于内容（也叫物品、项、item）的推荐系统：
2. 基于协同过滤的推荐系统

基于内容的推荐系统，根据用户过去喜欢的物品（内容），为用户推荐和他过去喜欢的物品相似的物品。而关键就在于物品相似性的度量；主要有三步：

1. 为每个物品提取特征
2. 利用该用户历史上喜欢或者不喜欢的物品，提取该用户的特征
3. 通过计算物品和用户的特征的距离，推荐相关度大的物品

基于协同过滤的推荐系统又分：

1. 基于用户的协同过滤：与A用户相似的用户的喜欢的内容，推荐给用户A
2. 基于内容的协同过滤：与A用户喜欢历史喜欢的内容相似的内容，推荐给用户A

内容的特征提取方法：

1. 文档的特征发现，例如TF.IDF，第四章的文档相似性，基于词汇来定义，而推荐系统关注的文档特征，是一些重要词汇的是否出现，而进一步的距离的度量、相似文档的发现，minhash LSH都在推荐系统里可用
2. 内容的标签
3. 内容的结构化资料

基于内容的推荐系统，还有一个思路是机器学习的方式，将特定的数据（例如一组历史上用户喜欢或者不喜欢的内容的特征作为输入特征，用户喜欢或者不喜欢作为分类标签）当做是训练集，然后为每个用户训练一个分类器，来预测该用户对一个内容的评分/喜好

协同过滤，关键步骤是计算相似性，可以用第四章介绍的距离度量的方式计算相似的用户/内容，也可以使用聚类的机器学习算法，聚类出相似的簇。

[试验代码](code/data_mining/UserCollaborativeFiltering.py)

基于用户和基于物品的协同过滤算法的对比：

![](img/data_mining/CF.JPG)



## 1.2、潜在因子算法

另外一种重要的推荐算法是潜在因子算法（latent factor model）

以下面四个用户对五个电影的打分为例。目标是预测一些用户对某部电影可能的评价，据此来决定要不要给该用户推荐。例如预测Alice对第三部电影的评价。

![](img/anomaly_detect/recommend1.jpg)

算法是：

1. 对每部电影，建立一些特征，类似线性回归例子中的每个房子有建筑面积、卧室个数等特征。上面例子的电影有两个特征：x1-浪漫类系数，x2-动作类系数
2. 每个用户是一个线性回归模型（也可以是其他机器学习模型），根据该用户对某些电影已有的评价信息，可以学习到该用户的线性回归参数θ。例如上面例子中，可以训练获得Alice用户的θ=[0, 5, 0]
3. 利用上一步学习获得的θ， 可以预测该用户对其他电影的评价，例如Alice对第三部电影的评价是4.95分

也可能的场景是，知道一些用户的模型参数θ，但是某些电影的特征数据缺失，例如下图：

![](img/anomaly_detect/recommend2.jpg)

类似的，可以依据已有的用户模型参数θ，训练获得电影的特征数据。然后利用学习到的数据，对缺失的评价进行预测。

在一个推荐系统里，往往两个方向的学习都有：只有部分用户模型参数θ，只有部分电影的特征数据x；利用已知的电影特征数据x，可以学习到缺失的用户模型参数θ；利用已知的用户模型参数θ，可以学习到缺失的电影的特征数据x。最终实现预测某用户对某电影是否感兴趣。

x1,x2这些特征因子、用户模型参数θ、物品的特征数据都可以由用户的评价矩阵生成，通过UV分解和梯度下降学习得到，[试验代码在这里](code/data_mining/LFM.py)

## 1.3、基于图的算法

将用户行为信息整理成二分图这样的数据结构：

1. 节点包括用户和物品
2. 如果用户历史上有访问某物品，就存在该用户到该物品的一条边

基于图的算法，从某个用户节点出发，在图上面游走，访问到的物品节点就是可能推荐给该用户的物品。游走中访问到的物品与该用户的相关度主要取决于：

1. 该用户到达物品的路径数目
2. 该用户到达物品的路径的长度
3. 该用户到达物品所经过节点的出度，出度越大相关度越低（大家都买了《新华字典》，只有少数程序员买了《深度学习》）

到具体实现，经典的实现算法有基于随机游走的PersonalRank算法（类似PageRank）：

1. 要给用户u推荐物品，从u对应的节点出发在二分图上随机游走。
2. 游走到任何节点，按照一定的概率p决定是：
   1. 继续游走
   2. 停止本次游走，重新从u开始游走
3. 如果决定继续游走，那么就从当前节点指向的节点中均匀随机的选择一个节点作为下一个经过的节点
4. 这样，经过很多次随机游走后，每个物品节点被访问到的概率收敛到一个数

[示例代码在这里]((code/data_mining/GraphRank.py))

