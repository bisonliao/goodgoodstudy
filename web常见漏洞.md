# 常见web安全漏洞学习笔记 #

（2012年）

--特别声明一下：即为学习笔记，很多内容来自阅读网上然后摘抄下来，一方面会与一些帖子或者文章雷同，也来不及注明转载，先致歉；另外一方面，有的内容我自己可能理解也不到位，或者偏绝对，例如“永远不要...”


## Xss ##

通俗的说：恶意攻击者往Web页面里插入恶意html代码，当用户浏览该页之时，嵌入其中Web里面的html代码会被执行，从而达到恶意用户的特殊目的。是代码注入的一种。

XSS攻击通常指的是通过利用网页开发时留下的漏洞，通过巧妙的方法注入恶意指令代码到网页，使用户加载并执行攻击者恶意制造的网页程序。这些恶意网页程序通常是JavaScript，但实际上也可以包括Java， VBScript， ActiveX， Flash 或者甚至是普通的HTML。攻击成功后，攻击者可能得到包括但不限于更高的权限（如执行一些操作）、私密网页内容、会话和cookie等各种内容。

---问题：对于外部提交的文本，我们通过转义的方式来避免xss，那对于Flash、ActiveX怎么办呢？

Henry说这种二进制化了都比较难检查了，一般会反编译

攻击者使被攻击者在浏览器中执行脚本后，如果需要收集来自被攻击者的数据（如cookie或其他敏感信息），可以自行架设一个网站，让被攻击者通过JavaScript等方式把收集好的数据作为参数提交，随后以数据库等形式记录在攻击者自己的服务器上。

避免XSS的方法之一主要是将用户所提供的内容进行过滤：

1、  将外部用户提供的内容进行过滤，读入和吐出的时候都进行转义。

2、  如果是有用户登录态信息的，尽量把网站隔离成几个区域，每个区域一个独立域名，每个区域的登录态cookie打在各自的域名下，且各区域的cgi不能互认登录态信息。这样一旦一个区域发生了xss漏洞，用户登录态信息泄漏或者被劫持，也只能影响本区域

3、  重要操作加入用户参与的校验，例如二次密码、图片验证码、短信验证码

4、  Cookie尽量设置属性httponly

## Csrf ##

CSRF通过伪装成来自受信任用户的请求来利用受信任的网站。在用户会话下对某个CGI做一些GET/POST的事情——这些事情用户未必知道和愿意做。攻击通过在授权用户访问的页面中包含链接或者脚本的方式工作。

定义没有什么好说的，完全不知所云，举个栗子更好：

1、  某银行网站（叫icbank吧）有一个cgi，叫做transfer_account，参数是目标账户和金额，向这个cgi提交请求后，cgi获取cookie里的用户登录态并校验，通过的话则向目标账户转账。过程中假设无需短信、验证码啥的用户确认。

2、  另外一个论坛叫devilpage吧，上面有一段恶意代码（可能是因为xss漏洞提交上去的，也可能是因为论坛主人本来就是恶意者），会自动向上述银行的转账cgi提交转账请求，例如http://icbank.com/transfer_account?dst=13234&amt=3000

3、  某天，一个衰人登陆了icbank，页面保持着没有退出登录也没有关闭页面；然后他又开了个tab顺便浏览一下devilpage，这个时候恶意代码就执行了，因为衰人的客户端有icbank的登录态，所以转账会成功

防范措施：

1、  将持久化的授权方法（例如file型的cookie或者HTTP授权）切换为瞬时的授权方法，例如前面的银行网站关于登录态的cookie的生命周期不要搞成文件型的，且只限制在icbank.com下

2、  在form中包含秘密信息（在每个form中提供隐藏field）、用户指定的代号作为cookie之外的验证。

3、   “双提交”cookie。如果服务器需要在Post请求体或者URL中包含授权cookie的请求，那么这个请求必须来自于受信任的域，因为其它域是不能从信任域读取cookie的。例如前面的银行转账cgi，要求url参数里再加一个用户登录态cookie加密后的字符串，并与cookie中的信息进行核对。那么恶意网站在构造url的时候，就无法提供这个参数，因为他的域名不同，这个时候还取不到cookie。当然，提交请求，浏览器在请求包里会自动带上icbank.com的cookie，但不是在url参数里

4、  与通常的想法相反，使用Post代替Get方法并不能提供卓有成效的保护。因为JavaScript能使用伪造的POST请求。尽管如此，那些导致对安全产生“副作用”的请求应该总使用Post方式发送。Post方式不会在web服务器和代理服务器日志中留下数据尾巴，然而Get方式却会留下数据尾巴。

5、  检查请求的referer信息，确保是来自可信任的域名，例如来自相同域名的引用

 

## Sql 注入 ##

当应用程序使用输入内容来构造动态sql语句以访问数据库时，语句中包含未筛选的用户输入的字符串，那么恶意者就可能把恶意的SQL命令注入到程序中执行，最终达到执行恶意的SQL命令的目的

许多网站程序在编写时，没有对用户输入的合法性进行判断或者程序中本身的变量处理不当，使应用程序存在安全隐患。这样，用户就可以提交一段数据库查询的代码，根据程序返回的结果，获得一些敏感的信息或者控制整个服务器，于是sql注入就发生了。

防御方法：

1、  永远不要信任用户的输入。对用户的输入进行校验

2、  永远不要使用动态拼装sql，可以使用参数化的sql（例如mysql里的statement）或者直接使用存储过程进行数据查询存取。

3、  永远不要使用管理员权限的数据库连接，为每个应用使用单独的权限有限的数据库连接。

4、  不要把机密信息直接存放，加密或者hash掉密码和敏感的信息。

5、  应用的异常信息应该给出尽可能少的提示，最好使用自定义的错误信息对原始错误信息进行包装

## url跳转漏洞 ##

由于应用越来越多的需要和其他的第三方应用交互，以及在自身应用内部根据不同的逻辑将用户引向到不同的页面，譬如一个典型的登录接口就经常需要在认证成功之后将用户引导到登录之前的页面，整个过程中如果不对跳转目标进行校验和限制就可能导致一些安全问题

可能的危害：

1、  会将用户浏览器从可信的站点导向到不可信的站点，安全意识较低的用户很可能会以为跳转后展现的内容还是可信的

2、  如果跳转的时候带有敏感数据一样可能将敏感数据泄漏给不可信的第三方。

3、  由于QQ，淘宝 旺旺等在线IM都是基于URL的过滤，同时对一些站点会一白名单的方式放过，所以导致恶意URL通过作为信任站点的跳转目标，实现在IM里可以传播，从而产生危害。

4、  如果引用一些资源的限制是依赖于“白名单方式”，同样可能被绕过导致安全风险，譬如常见的一些应用允许引入可信站点如youku.com的视频，限 制方式往往是检查URL是否是youku.com来实现，如果youku.com内含一个url跳转漏洞，将导致最终引入的资源属于不可信的第三方资源或 者恶意站点，最终导致安全问题。

防御方法：

我们需要对传入的URL做有效性的认证，保证该URL来自于正确的地方，限制的方式同防止csrf一样可以包括：

1、  referer限制：确定传递url跳转参数的来源，看是不是可信的来源，这些来源一般不会随意指定跳转目标

2、  在生成的链接中加入用户不可控的token，例如本域才可以取到的cookie，进行双提交

3、  对跳转的目标进行白名单限制

## 会话ID窃取 ##

由于HTTP本身是无状态的也就是说HTTP的每次访问请求都是带有个人凭证的而SessionID就是为了跟踪状态的而sessionID本身是很容易在网络上被监听的到所以攻击者往往通过监听sessionID来达到进一步攻击的目的。

危害主要是冒充真正用户进行web应用访

防御方法：

1、  https

2、  对sessionid进行客户端IP限制，盗走了也不能用

## 访问控制错误漏洞 ##

Web服务器敏感目录或者敏感文件权限设置不当导致被攻击者查看

## 钓鱼网站 ##

钓鱼网站通常是指伪装成银行及电子商务等网站，主要危害是窃取用户提交的银行帐号、密码等私密信息。所谓“钓鱼网站”是一种网络欺诈行为，指不法分子利用各种手段，仿冒真实网站的URL地址以及页面内容，或者利用真实网站服务器程序上的漏洞在站点的某些网页中插入危险的HTML代码，以此来骗取用户银行或信用卡账号、密码等私人资料。

它一般通过电子邮件、IM、微博等传播，此类消息/邮件中一个经过伪装的链接将收件人联到钓鱼网站。钓鱼网站的页面与真实网站界面完全一致，要求访问者提交账号和密码。一般来说钓鱼网站结构很简单，只有一个或几个页面，URL和真实网站有细微差别。

应对方式

1、  通过第三方网站身份诚信认证辨别网站真实性。或者进行ICP备案

2、  教育用户核对网站域名

3、  使用https，并教育用户注意查看安全证书

## 网络中间人劫持 ##

按理说不是web特有的安全问题。通过在通信网络中插入恶意代码或者设备，从而篡改下行页面、或者篡改上行请求、或者截获敏感信息，从而实现恶意者的目的，例如：

1、  对登录页面进行篡改，恶意盗取用户密码

2、  对页面进行篡改，曝露色情政治和广告信息

应对办法：

https

## 域名劫持 ##

通过攻击域名解析服务器（DNS），或伪造域名解析服务器（DNS）的方法，把目标网站域名解析到错误的地址而达到无法访问目标网站的目的。

应对办法：

对DNS服务器进行加固和漏洞修复

 

## 附一些零碎的知识： ##

1、  cookie的secure属性 当设置为true时，表示创建的 Cookie 会被以安全的形式向服务器传输，也就是只能在 HTTPS 连接中被浏览器传递到服务器端进行会话验证，如果是 HTTP 连接则不会传递该信息，所以不会被窃取到Cookie 的具体内容。

2、  cookie的HttpOnly属性 如果在Cookie中设置了"HttpOnly"属性，那么通过程序(JS脚本、Applet等)将无法读取到Cookie信息，这样能有效的防止XSS攻击。

