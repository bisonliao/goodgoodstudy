原书标题是 the scientist and engineers guide to digital signal processing

是一本开源的书，官网上可以下载到：http://dspguide.com/

# 第一章：数字信号处理的广泛用途 #

我们研究的信号，通常是一个时间序列的变量，可以使离散的，也可以是连续的。信号也可以是时间以外的自变量的因变量。

一个信号经过一个系统，输出为另外一个信号。

# 第二章：统计、概率和噪声 #

生成正态分布的随机数的两个方法：

方法一：基于中心极限定理累加

1. 生成12个[0,1]之间均匀分布的随机浮点数，将他们累加得到v
2. v减去6，使得随机数均值为0，此时标准差为1
3. v乘以目标正态分布的标准差
4. v加上目标正态分布的均值

方法二：基于公式

1. 生成2个[0,1]之间均匀分布的随机浮点数R和Q
2. 计算v=（-2log(R))^(0.5)  * cos(2Pi*Q)

# 第三章：ADC和DAC #

主要是讲量化和采样。

重点是奈奎斯特采样定理，见另外一篇专门的文章：


[奈奎斯特采样定理的理解.md](奈奎斯特采样定理的理解.md)

# 第四章：DSP软件 #

主要是讲浮点数的舍入误差问题。

由于计算机是使用有限的状态位（例如float用32bit）来表示状态数为无限个的一定范围的实数，所以运算过程中会经常出现把一个实数值舍入到某个状态，从而引入了舍入误差。

具体的一些性质可以参考：

[IEEE754标准](https://en.wikipedia.org/wiki/IEEE_754)

[单精度浮点数](https://en.wikipedia.org/wiki/Single-precision_floating-point_format)

[双精度浮点数](https://en.wikipedia.org/wiki/Double-precision_floating-point_format)

[试验代码](https://github.com/bisonliao/daydayup/blob/master/acm/float.c)

# 第五章：线性系统 #

线性系统的几个特征：

1. 同质性（我感觉叫可乘性比较好）：输入X，输出Y，如果输入aX，a是常数，则输出aY
2. 可加性：输入X1，输出Y1，输入X2，输出Y2，如果输入X1+X2，则输出Y1+Y2
3. 时移不变性：（通常是基于时间的）输入信号平移一个常量，输出信号也对应的会平移一个常量
4. 静态保持性：输入是一个常量信号，输出也是一个常量信号
5. 正弦保持新：输入是正弦波，输出也是同频率的正弦波，只是相位和幅度可能改变

DSP的基本思路：将复杂信号分解为多个简单信号，这些分量通过线性系统变化后的输出信号，叠加起来等于复杂输入信号的输出

1. 输入信号X分解为一组分量x1,x2,...
2. 这些分量通过线性系统，输出为一组y1,y2,...
3. 将y1，y2,...这些输出分量叠加得到Y，Y就是X通过线性系统的输出

![](img/dsp/fundamental.jpg)

将一个信号分解的方法：

1. 脉冲分解：把长度为n的时间序列的信号看做n个对应时间点上的脉冲信号的叠加
2. 傅里叶分解：把信号看做是非常多频率的正弦波信号的叠加。任意N个点的离散信号，可以分解为N+2个信号， 其中一半是正弦，另外一半是余弦。
3. 步进分解
4. 奇偶分解
5. 交错分解

前面两种分解是特别重要的。

# 第六章：卷积 #

第六章暂时只讨论离散信号。

几个概念：

1. 单位脉冲：也叫delta函数，时间点第一个位置的信号值为1，其他都为0
2. 脉冲反应：单位脉冲经过一个线性系统后的输出
3. 任一脉冲信号可以看做是单位脉冲经过时移和缩放后得到的脉冲信号，所以其经过一个线性系统后的输出信号，可以由该系统的脉冲反应做对应的时移和缩放得到。
4. 同理，任一信号经过一个线性系统后的输出信号：  a）输入信号X分解为多个脉冲信号P1,P2,P3...，根据系统的脉冲反应，做相应的时移和缩放，得到输入信号的分量的对应输出信号O1,O2,O3....。   b）将O1，O2，O3...叠加，就得到X信号经过系统后的输出信号Y
5. 上面的这个过程就是卷积，该系统的脉冲反应也叫做卷积核，或者叫做核。

下图是一个例子：

![](img/dsp/convolution_sample.jpg)

使用mathematica软件验算一下：

	input = {0, -1, -1.2, 2, 1.4, 1.4, 0.6, 0, -0.6, 0, 0, 0};
	kernel = {1, -0.5, -0.3, -0.1};
	output = ListConvolve[kernel, input, 1];
	ListPlot[output]

输出的output同y[n]：

![](img/dsp/convolution_out.jpg)

需要稍微注意一下：mathematica的ListConvolve函数，计算方式会与教材不一致，边界的处理上有些不同。  所以要第三个参数指定为1，且input后面补一些0。

卷积可以从输入侧和输出侧两个视角做物理上的理解。

## 输入侧视角来理解卷积 ##

输入侧视角，把卷积理解为 卷积核（系统的脉冲反应）的多次时移和缩放后的信号的叠加。

例如有输入信号X[n]，由9个离散的值组成：X(0),X(1),X(2)...X(8)，每个值都作用于卷积核，得到一个输出信号y，总共得到有9个输出信号，叠加起来得到输入信号。

假设X[4]等于1.4，X(4)=1.4*Delta[n-4]，即X[4]是单位脉冲时移4并缩放1.4倍。X[4]经过系统后产生一个输出信号y(4)，y(4)就是卷积核时移4并缩放1.4倍。同理有y(0),y(1)...y(8)，他们叠加起来就是X和系统的脉冲反应卷积的结果。

![](img/dsp/convolution_input_side.jpg)

卷积操作在数学上是满足交换律的。

## 输出侧视角来理解卷积 ##

还是上面的例子，有输入信号X[n]，由9个离散的值组成， 卷积核宽度为4，即有4个离散值组成，输出将会有12个值（9+4-1）。从输入侧的视角来看，卷积核会不断时移，也就是像个窗口一样在输出信号的时间轴上一步一步向右移动。

对于具体的一个输出信号的取值，例如y(6)，它是有哪些值叠加产生的呢？ 当卷积核经过y(6)所在位置的时候，都会贡献分量给它，当卷积核窗口没有和y(6)位置重合的时候，输出分量取值都是0.


![](img/dsp/kernel_move.jpg)

所以，输出信号的某个时间点取值y(i)，是翻转后的卷积核与X(i-M+1),...,X(i)这些值相乘再累加的结果。卷积核不断的右移，不断的产生出y(i)。M是卷积核大小。

![](img/dsp/convolution_output_side.jpg)

有公式：

	y(i) = SUM( h(j) * X(i-j)， j from 0 to M-1）

# 第七章：卷积的一些性质 #

一个线性系统的特性，可以认为完全由它的脉冲响应（卷积核）决定和表现，这是数字信号处理的基础。数字滤波器就是不同的卷积核，不同的卷积核，对输入信号的处理有不同的性质表现。

卷积核是一个单位脉冲信号：该滤波器表现为将输入信号原样输出，x(n) * h(n) = x(n)

卷积核是一个缩放过的单位脉冲信号：信号放大器、信号衰减器，x(n) * k h(n) = k x(n)

卷积核是一个时移的单位脉冲信号：信号延时器

一阶差分器和积分器：

![](img/dsp/difference_sum.jpg)

它们是互为逆操作：

![](img/dsp/difference_sum2.jpg)

低通滤波器：卷积核通常由一组连续的整数点组成，卷积操作是对输入信号附近的值做加权平均，从而平滑掉高频分量。

高通滤波器：卷积核通常由一个单位脉冲信号减去一个低通滤波器得到。可以理解为从原信号中减去低频部分，就剩下高频部分了。

因果系统：输入信号的某个时间点的值，值影响该时间点及其以后的输出信号的值，即卷积核的负时间点坐标上的值都为0（数学上完全可以存在负时间点坐标上的值不为0的卷积核）。

![](img/dsp/causal_signal.jpg)

零相位：如果一个信号的一系列值在横坐标0左右对称，则称为零相位的

线性相位：如果一个信号的一系列值在横坐标某个点左右对称，则称为线性相位

这两个概念在这章比较费解，不直观，后面DFT学了之后就直观了。

卷积在数学上的一些属性：

1. 满足交换律
2. 满足结合律
3. 满足分配率
4. 输入输出的传递性：在输入上施加操作后经过一个系统，该操作也会在输出信号上体现出来。例如对一个输入信号施加时移、缩放、积分、求导，经过一个系统后的输出信号，也等于在原输出信号上施加时移、缩放、积分、求导的结果。  时移、缩放好理解，是线性系统的定义决定的。积分和求导也可以，比较新奇。
5. 中心极限定理效应：一个“脉冲形状”的输入信号，反复与自己卷积，最后的结果是一个“正态分布形状”的信号

![](img/dsp/central_limit_theory.jpg)

中心极限定理效应比较有意思，用mathematica软件可以试验一下。注意：为了让卷积核这个窗口在信号左右两边都滑动到位，试验的时候需要给输入信号两边都加一些0.0的个数等于卷积核长度减去1.

	K = {1, 2, 2, 1};
	input = {0, 0, 0, 1, 2, 2, 1, 0, 0, 0};
	input = ListConvolve[K, input]

上述代码输出为

	{1, 4, 8, 10, 8, 4, 1}

可以看到比input一开始更接近正态分布形状。

继续：

	input = {0, 0, 0, 1, 4, 8, 10, 8, 4, 1, 0, 0, 0};
	input = ListConvolve[K, input]

输出为：

	{1, 6, 18, 35, 48, 48, 35, 18, 6, 1}

如此反复多次，可以得到input的形状如下：

![](img/dsp/central_limit_theory2.jpg)

实际上输入信号一开始的形状也可以随意一点，例如

	K={1,4,6,8};
	input={0, 0, 0, 1, 4, 6, 8, 0, 0, 0};
	input=ListConvolve[K,input]

经过几次卷积后，形状也逼近正态分布：

![](img/dsp/central_limit_theory3.jpg)

# 第八章：离散傅里叶变换（DFT） #

一个信号，分解为一组分量叠加的形式，可以有无数种方法，例如前面提到的脉冲分解、步进分解等。而傅里叶变换，把信号分解为一组不同频率的正弦波叠加的形式。是因为正弦波经过一个线性系统后，还是同频率的正弦波，只有相位和幅度发生变化。而其他形状的分量则没有这么利于分析的性质。

严格来说，对于连续的信号，在不可导点，傅里叶变化不能精确与原信号相等，但可以尽量逼近。而对于一个个离散的信号值，则没有这样的问题。

傅里叶变换簇有四种情形：

1. 对周期的连续信号进行分解，称为傅里叶级数（FS）。
2. 非周期的连续信号进行分解，称为傅里叶变换（FT）。例如高斯函数、指数函数等
3. 对周期的离散信号进行分解，称为离散傅里叶变化（DFT）。通常我们拿到一组有限个数的离散值做DFT，似乎不是周期的，实际上在变换的时候，约定俗成将这组离散值向时间轴两侧做周期性重复扩展。本章讨论的就是这种情形。
4. 对非周期的离散信号进行分解，称为离散时间傅里叶变换（DTFT）。

这四种情形的变换，处理的信号都是在时间轴的负无穷到正无穷范围内的。怎么理解，例如对于情形3，前面已经说了，要“想象”为周期性的重复扩展；对于情形4和情形2，没有明确定义的时间轴上的值，要“想象”为0。

mathematica软件也有一组函数对应上述四种情形：

![](img/dsp/mathematica_ft_function.jpg)

本章集中阐述DFT是实数DFT，预算结果与mathematica的Fourier函数的结果不一样，Fourier函数是复数DFT，这两者的差异和关系将在第十二章讲。

实数DFT可以认为是这样一个系统：

1. 输入N个离散点组成的信号x(n)，n取值为0到N-1.
2. 输出为有 N/2 + 1 个复数点的**X**(k)，k取值为0到N/2.
3. **X**(k)被称为x(n)频域信号，x(n)被称为时域信号

输入输出的关系是：

这些复数**X**(k)的实部是对应Cos分量的幅度，其虚部是对应Sin分量的幅度。这些分量叠加起来，即可合成x(n)。公式里的X上面加了一横，与X有直接关系。具体关系公式不抄录了。

![](img/dsp/DFT_concept.jpg)

下面是mathematica代码实现的上述版本的DFT：

	input = {1, 2, 3, 4, 5, 6, 7, 8};
	NUM=Length[input];
	ReX[k_] = Sum[ Extract[input, i + 1]*Cos[2 Pi/NUM * k * i], {i, 0, NUM-1}];
	ImX[k_] = -Sum[    Extract[input, i + 1]*Sin[2 Pi/NUM * k * i], {i, 0, NUM-1}];
	ReXX[k_] = If[k == 0||k==NUM/2, ReX[k]/NUM, ReX[k]/NUM * 2];
	ImXX[k_] = -ImX[k]/NUM *2;
	INPUT[i_] =  Sum[ReXX[k] *Cos[2 Pi/NUM*k*i], {k, 0, NUM/2}] +   Sum[ImXX[k]*Sin[2 Pi/NUM * i * k], {k, 0, NUM/2}];
	Table[INPUT[i], {i, 0, NUM/2}]//N

可以看到，最后输出的INPUT值和input值是一致的。

c代码实现版本：

[code/dsp/dft.c](code/dsp/dft.c "dft.c")


![](img/dsp/mathematica_dft_example1.png)


我感觉这些分量有两个“频率”，一个是数学上的正弦波的周期和频率，一个是DFT中通常说的频率： 

假设输入的离散信号的采样点个数 NUM = 1000， DFT的第k个分量的 k = 100, 对应的正弦波分量有 Cos[ 2Pi / 1000 * 100 * i]和Sin[2Pi / 1000 * 100 * i]， 当i从0到10范围内，出现一个完整的周期，如果采样点间隔时间是1s，则从数学上看这个波的频率是1/10，但DFT中通常不这么说，而是看这个波在0到NUM个点范围内出现了几个完整周期，0到10一个完整周期，10到20又一个完整周期... 那么0到NUM（NUM这里等于1000） 范围内就会出现100个完整周期，通常说这个分量的频率是100. 

**规律就是k等于多少，这个分量的频率就是多少。 进一步的，有N个点，DFT结果的分量频率范围是从1到N/2（第二个版本是N）**。

那取点数NUM的多少会不会影响各分量的频率？ 答案是会影响DFT所说的频率，但数学上的频率还是一样的。例如下面对同一个周期离散信号采样不同的个数的对比：

![](img/dsp/dft_frequence.jpg)

**实验一：验证一下一个正弦波的采样点的频谱图是不是刚好一个脉冲？**

实验如下：

	input = Table[ Sin[x], {x, 0, 4Pi, 0.6}];
	NUM = Length[input];
	ReX[k_] = Sum[Extract[input, i + 1]*Cos[2Pi/NUM*k*i], {i, 0, NUM - 1}];
	ImX[k_] = -Sum[Extract[input, i + 1]*Sin[2Pi/NUM*k*i], {i, 0, NUM - 1}];
	ReXX[k_] = If[k == 0 || k == NUM/2, ReX[k]/NUM, ReX[k]/NUM*2];
	ImXX[k_] = -ImX[k]/NUM*2;
	INPUT[i_] = Sum[ReXX[k]*Cos[2Pi/NUM*k*i], {k, 0, NUM/2}] +   Sum[ImXX[k]*Sin[2Pi/NUM*i*k], {k, 0, NUM/2}];
	ListPlot[   Table[  Sqrt[ReXX[k] * ReXX[k] + ImXX[k]*ImXX[k]], {k, 0, NUM/2 - 1}]，PlotRange -> All]

输出如下：

![](img/dsp/sin_spectrum.jpg)

提醒：由于各值之间相差悬殊，上面代码ListPlot函数的PlotRange参数尤其重要，否则显示很奇怪会误导。另外ListPlot打的第一个点x轴是1不是0，和程序中的下标k不一致，k是从0开始。

进一步算一下频率是否对。假设上面的Sin信号的频率是2Hz，那么1秒内有2个周期。采样点是对4Pi也就是1s时长的信号采样21次，即采样频率是21Hz。频谱显示在k=2，也就是2/21 * 21 = 2Hz，所以符合预期。 

用Fourier[]函数计算的DFT也是这样的结果。从这个例子来看，该书中提出的N/2+1个频率更科学，因为Fourier函数计算出来的右半部分频率，不符合奈奎斯特采样原理，而且导致了左半部分的频率的幅度减半。虽然从信号叠加的角度是ok的。

**实验二：两个同频率的Sin函数，他们差异只是时移，叠加产生的输入信号，DFT后的频谱是怎样的？**

**实验三：两个频率相差很细微的Sin函数，假设频率分别是41和43，一开始相位是一致的，随着时间推移，相位差异越来越大，叠加出来的信号频率应该下降了。 采样和DFT需要注意什么**

## 极坐标表达形式 ##

前面所用的ReX[k]和ImX[k]的方式，被称为三角函数表达方式，同一频率的实部和虚部分别是Cos和Sin正弦波的幅度，叠加起来表现是一个正弦波。根据   ACos(x) + BSin(x) = M Cos(x+θ) 可得到叠加后的正弦波幅度和相位偏移,这种表达方式称为极坐标表达形式：

	MagX[k] = (ReX[k] ^ 2 + ImX[k] ^ 2) ^ 0.5
	PhaseX[k] = θ = arctan(ImX[k]/ReX[k])

反向的转化公式：

	ReX[k] = MagX[k] * Cos( PhaseX[k] )
	ImX[k] = MagX[k] * Sin( PhaseX[k] )

![](img/dsp/polar_notation.jpg)


# 第九章：DFT的应用 #

最主要的应用当然是分析信号的频谱。

**线性系统的频率反应（frequence response）**

任何输入信号都可以表示为一组正弦波的叠加，经过一个线性系统后，这些正弦波频率不变，只是幅度和相位发生变化，然后叠加得到输出信号。线性系统对经过它的正弦波的改变性质，称为该系统的频率反应。

线性系统的频率反应，也就是它的脉冲反应的DFT结果。

这么来理解，想象一下：

1. 一个脉冲信号，经过一个线性系统，输出是该系统的脉冲反应。这是时间域的卷积。 
2. 频域的一个脉冲信号，其时间域对应的是一个正弦波。正弦波经过线性系统，频率不变，相位和幅度发生变化，这里的变化属性，就应该和脉冲反应的频域有关，也就是脉冲反应的DFT结果。

为了提高线性系统频率反应的结果分辨率，可以将脉冲反应左右增加足够多的0，当左右时间轴全都是0的时候，周期信号变成了非周期信号，DFT演化成了DTFT，傅里叶变换的结果也从离散频谱变成了连续的频谱。

前面的试验可以发现，对一个连续信号更密集的采样，即增大DFT处理的输入样本的个数N，也能让频谱有更高的分辨率。但这里不要妄想对脉冲反应做更密集的采样，因为脉冲反应就是一个离散信号，没法更密集的“采样”。

一个输入信号x(n)，经过一个线性系统，其脉冲反应是h(n)，输出信号是两者的卷积：y(n) = x(n)*h(n)

对应的，我们可以吧输入信号和脉冲反应都做DFT，得到X(n)和H(n)，两者相乘后做IDFT，可得到y(n)。

这么乘：

![](img/dsp/multi_of_frequence.jpg)

我的验证结果似乎不符合预期，不知道问题出在哪里：

直接卷积的结果：

	input={1,-1,1,-1};
	input2={0,0,0,1,-1,1,-1,0,0,0};
	resp={1,2,3,4};
	ListConvolve[resp,input2]

输入信号DFT：

	input={1,-1,1,-1};
	NUM=Length[input];
	ReX[k_]=Sum[Extract[input,i+1]*Cos[2 Pi/NUM*k*i],{i,0,NUM-1}];
	ImX[k_]=-Sum[Extract[input,i+1]*Sin[2 Pi/NUM*k*i],{i,0,NUM-1}];
	RX=Table[ReX[k], {k,0,NUM/2}];
	IX=Table[ImX[k], {k, 0, NUM/2}];

卷积核做DFT：

	input={1,2,3,4};
	NUM=Length[input];
	ReX[k_]=Sum[Extract[input,i+1]*Cos[2 Pi/NUM*k*i],{i,0,NUM-1}];
	ImX[k_]=-Sum[Extract[input,i+1]*Sin[2 Pi/NUM*k*i],{i,0,NUM-1}];
	RH=Table[ReX[k],{k,0,NUM/2}];
	IH=Table[ImX[k],{k,0,NUM/2}];

两者相乘：

	RY = RX * RH - IX * IH;
	IY = IX * RH + RX * IH;

	（*
	RY=Table[Extract[ RX,k+1]*Extract[RH, k+1]-Extract[IX,k+1]*Extract[IH,1+k], {k, 0, NUM/2}];
	IY=Table[Extract[ IX,k+1]*Extract[RH, k+1]+Extract[RX,k+1]*Extract[IH,1+k], {k, 0, NUM/2}];
	*）

逆变换：

	NUM=4;
	ReXX[k_]=If[k==0||k==NUM/2,Extract[RY,1+k]/NUM,Extract[RY,1+k]/NUM*2];
	ImXX[k_]=-Extract[IY,1+k]/NUM*2;
	INPUT[i_]=Sum[ReXX[k]*Cos[2 Pi/NUM*k*i],{k,0,NUM/2}]+Sum[ImXX[k]*Sin[2 Pi/NUM*i*k],{k,0,NUM/2}];
	Table[INPUT[i],{i,0,NUM-1}]//N

# 第十章：傅里叶变换的属性 #

## 傅里叶变换的线性性质 ##

1. 可乘：if x[] <-> X[], then kx[] <-> kX[]，即幅度伸缩k倍，而相位角不变
2. 可(叠)加：if x1[n] + x2[n] = x3[n]， then ReX1[f] + ReX2[f] = ReX3[f] 且 ImX1[f] + ImX2[f] = ImX3[f]

![](img/dsp/DFT_additivity.jpg)

## 相位角的特性 ##

时间域的信号时移对相位角的影响：

	if x[n] <-> MagX[f] & PhaseX[f]， 
	then x[n+s] <-> MagX[f] & PhaseX[f] + 2Pi*s*f, 其中f采用0到0.5这种小数比值表示法

可以通过mathematica简单验证一下：

	input={1,2,3,4,5,6,7,8,0,0,0,0};
	NUM=Length[input];
	ReX[k_]=Sum[Extract[input,i+1]*Cos[2 Pi/NUM*k*i],{i,0,NUM-1}];
	ImX[k_]=-Sum[Extract[input,i+1]*Sin[2 Pi/NUM*k*i],{i,0,NUM-1}];
	MagX[k_]=(ReX[k]*ReX[k]+ImX[k]*ImX[k])^0.5;
	PhaseX[k_]=ArcTan[ReX[k],ImX[k]];
	P1 = Table[PhaseX[k],{k,0,NUM/2}];

	input={0,1,2,3,4,5,6,7,8,0,0,0};
	NUM=Length[input];
	ReX[k_]=Sum[Extract[input,i+1]*Cos[2 Pi/NUM*k*i],{i,0,NUM-1}];
	ImX[k_]=-Sum[Extract[input,i+1]*Sin[2 Pi/NUM*k*i],{i,0,NUM-1}];
	MagX[k_]=(ReX[k]*ReX[k]+ImX[k]*ImX[k])^0.5;
	PhaseX[k_]=ArcTan[ReX[k],ImX[k]];
	P2=Table[PhaseX[k],{k,0,NUM/2}];

	（*P1 = P1 + {0,0,0,0, 2Pi, 0,0};*）
	
	(P1-P2)/(2Pi) * NUM//N

输出中有一个数字不符合预期：-8。这是因为相位角有个2Pi的周期差导致的。即P1[4]绝对值比较大，相当于 2Pi * k + θ，就只保留了θ，所以代码里手工修正了一下， 见倒数第二行的注释。

	{0., 1., 2., 3., -8., 5., 6.}


如果输入信号在横坐标0的位置左右对称，DFT后相位是0，这个就是**零相位信号**，这类信号的特征是：虚部都为0。

mathematica验证如下，注意ReX ImX计算公式里的i的区间值不是0到NUM-1， 而是从-OFFSET开始了：

	input={1,2,3,4,5,6,5,4,3,2,1};
	NUM=Length[input];
	OFFSET=5;
	ReX[k_]=Sum[Extract[input,i+OFFSET+1]*Cos[2 Pi/NUM*k*i],{i,-OFFSET,NUM-OFFSET-1}];
	ImX[k_]=-Sum[Extract[input,i+OFFSET+1]*Sin[2 Pi/NUM*k*i],{i,-OFFSET,NUM-OFFSET-1}];
	MagX[k_]=(ReX[k]*ReX[k]+ImX[k]*ImX[k])^0.5;
	PhaseX[k_] = ArcTan[ ReX[k], ImX[k]];
	Table[ PhaseX[k], {k, 0, NUM/2}]//N
	

上面代码中的信号0采样点的值由6改为1就不对了，这时候实部有正有负，虚部为0， 所以相位角有0有Pi。但书里面没有提这种情况，作者直接用ArchTan[ImX[k]/ReX[k]]求相位角，可以看到：当虚部为0的时候，实部有正有负、相位角有0有Pi的这个情况被这个公式掩盖了。

如果输入信号是左右对称的，但是不是以横坐标0为对称中心点， 这种情况下具有线性相位，这类信号称为**线性相位信号**。

我理解这种情况下，输入信号可以当做由零相位信号进行时移后得来的，那自然是在0相位的基础上+2Pi*f*t， 这是一个f的线性函数，所以线性相位信号DFT后的相位是一条直线。

特别需要注意的是，用mathematica代码验证线性相位，可能看到相位不是一条直线，这是因为相位角有个2Pi的周期差导致的。即本来是一条直线，但到了后面因为绝对值比较大，相当于 2Pi * k + θ，就只保留了θ，导致图形上不是一条直线，所以代码里手工修正了一下。越到图形的右边，可能还需要减去4Pi甚至6Pi呢。

	input={1,2,3,4,5,6,5,4,3,2,1};
	NUM=Length[input];
	OFFSET=3;
	ReX[k_]=Sum[Extract[input,i+OFFSET+1]*Cos[2 Pi/NUM*k*i],{i,-OFFSET,NUM-OFFSET-1}];
	ImX[k_]=-Sum[Extract[input,i+OFFSET+1]*Sin[2 Pi/NUM*k*i],{i,-OFFSET,NUM-OFFSET-1}];
	MagX[k_]=(ReX[k]*ReX[k]+ImX[k]*ImX[k])^0.5;
	PhaseX[k_]=ArcTan[ReX[k],ImX[k]];
	P=Table[PhaseX[k],{k,0,NUM/2}]//N
	P=P-{0,0,0,2Pi,2Pi,2Pi};(* modify the chart by hand*)
	ListLinePlot[P, PlotRange->All]

## 紧缩和膨胀 ##

DFT前后，一个域的信号越紧缩，对应另外一个域的信号就越膨胀。即： 
	
	if x(t) <-> X(f)， 
	then x(kt) <-> 1/k X(f/k)

## 调幅 ##

傅里叶变换很重要的一个特征是，在一个域的卷积，对应在另外一个域的乘法。前面提到时间域的卷积，对应频域的乘法，反之也是这样。

时间域的乘法，对应在频域的卷积，有个很重要的应用就是调幅，例如收音机信号的AM调制。如下图所示：

![](img/dsp/AM.jpg)

写一段mathematica代码演示一下：

	sampleX=Range[0, 10, 0.01]; (*1000 samples*)
	input=Table[ (Sin[20t]+1.5)/(t+1), {t, sampleX}]; (*audio signals*)
	input1 = input;
	ListLinePlot[input1]
	NUM=Length[input];
	OFFSET=0;
	ReX[k_]=Sum[Extract[input,i+OFFSET+1]*Cos[2 Pi/NUM*k*i],{i,-OFFSET,NUM-OFFSET-1}];
	ImX[k_]=-Sum[Extract[input,i+OFFSET+1]*Sin[2 Pi/NUM*k*i],{i,-OFFSET,NUM-OFFSET-1}];
	MagX1[k_]=(ReX[k]*ReX[k]+ImX[k]*ImX[k])^0.5;
	PhaseX1[k_]=ArcTan[ReX[k],ImX[k]];
	M1 = Table[MagX1[k], {k, 0, NUM/2}];
	
	
	input=Table[ Sin[100t], {t, sampleX}]; (*carrier*)
	input2 = input;
	ListLinePlot[input2]
	NUM=Length[input];
	OFFSET=5;
	ReX[k_]=Sum[Extract[input,i+OFFSET+1]*Cos[2 Pi/NUM*k*i],{i,-OFFSET,NUM-OFFSET-1}];
	ImX[k_]=-Sum[Extract[input,i+OFFSET+1]*Sin[2 Pi/NUM*k*i],{i,-OFFSET,NUM-OFFSET-1}];
	MagX2[k_]=(ReX[k]*ReX[k]+ImX[k]*ImX[k])^0.5;
	PhaseX2[k_]=ArcTan[ReX[k],ImX[k]];
	M2 = Table[MagX2[k], {k, 0, NUM/2}];
	
	input = input1 * input2; (*modulate*)
	ListLinePlot[input]
	NUM=Length[input];
	OFFSET=5;
	ReX[k_]=Sum[Extract[input,i+OFFSET+1]*Cos[2 Pi/NUM*k*i],{i,-OFFSET,NUM-OFFSET-1}];
	ImX[k_]=-Sum[Extract[input,i+OFFSET+1]*Sin[2 Pi/NUM*k*i],{i,-OFFSET,NUM-OFFSET-1}];
	MagX3[k_]=(ReX[k]*ReX[k]+ImX[k]*ImX[k])^0.5;
	PhaseX3[k_]=ArcTan[ReX[k],ImX[k]];
	M3 = Table[MagX3[k], {k, 0, NUM/2}];
	
	ListLinePlot[ M1, PlotRange->All]
	ListLinePlot[ M2, PlotRange->All]
	ListLinePlot[ M3, PlotRange->All]

![](img/dsp/AM2.jpg)

这章还讲了DTFT公式、帕萨瓦尔能量公式。

# 第十一章：傅里叶变换对子 #

傅里叶变换前后，信号的波形彼此对应，例如 sin信号经DFT后是一个脉冲，这样的一对波形叫做傅里叶变换对子。而且两者交换后也成立。

但因为DFT后有实部、虚部、幅度、相位四个变量的波形，在研究傅里叶变换对子的时候，通常要明确指出是哪个变量。

常见的傅里叶变换对子有：

1. 时间域脉冲对应常数波形的频域幅度（正弦波形的实部和虚部， 相位是一条直线）
2. 时间域的方波对应sinc波形的频域幅度（相位是一条直线）
3. 时间域的三角波对应sinc平方的频域幅度
4. 时间域的高斯函数和高斯冲击都对应高斯函数的频域幅度
5. 一个sample构成的信号的DFT就是它本身。

本章还讲了吉布斯效应、谐波、线性调频。 

# 第十二章：快速傅里叶变换 #

FFT是DFT的计算复杂度改善版本，是基于复数DFT的。

![](img/dsp/complex_dft.jpg)

我们可以借助复数DFT来计算实数DFT，从而利用FFT快速计算的能力：

1. 将实数的时间信号填写到复数DFT的时间域信号的实部， 虚部都填0
2. 计算复数DFT
3. 取计算结果的实部和虚部的前[0,N/2]部分的值，即为实数DFT的结果

反向DFT也可以如此：

1. 将实数DFT频域的实部和虚部分别填写到复数DFT频域的实部和虚部的[0, N/2]部分
2. 余下的(N/2, N)部分，是将[0, N/2]部分翻转后平移再填入
3. 计算复数的IDFT
4. 取计算结果的实部即为实数IDFT的结果，这时计算结果的虚部应该为0.

FFT的主要思想，就是把长度为N的复数DFT（其复杂度为O(N^2)），拆分为两个长度为N/2的复数DFT，则其复杂度降低为 N+（N/2)^2， 进一步的拆分更多更短的DFT（最后是拆分为N个长度为1的DFT），计算复杂度可以降低到 O(nlogn)。

# 第十三章：连续信号处理 #

据作者的观点，连续信号的处理，是与DSP并行的一个领域。且几乎所有技术与思想都很相似：卷积、线性系统、傅里叶变换、分解与叠加。

## Delta 函数 ##

对应离散信号里的单位脉冲信号，连续信号处理领域有个Delta函数，它的定义是：

1. 这个信号在t=0处非零且无限窄，在t的其他位置为0
2. 这个信号的面积为1

同样的，一个线性系统的特性完全由它对Delta函数的响应决定，也就是脉冲响应。

## 连续信号的卷积 ##

连续信号的卷积的物理意义就是：将输入信号拆解为无数多个被缩放和时移的Delta函数。每个缩放、时移后的Delta函数经过线性系统，产生无数多个被缩放和时移的脉冲响应。这些脉冲响应叠加起来，就是卷积的结果，即输入信号经过系统后的输出。

![](img/dsp/continuous_convolution.jpg)

一个mathematica演示的例子：

	x[t_]=If[t>=0&&t<=1,1,0];
	h[t_]=If[t<=0,0,E^(-t)];
	Plot[{x[t], h[t]}, {t, -3, 3}]
	y[t_]:=Integrate[x[s]*h[t-s],{s,-10000,10000}];
	(*Infinity cause crash,so change it to 1000000*)
	Plot[y[t],{t,-10,10},PlotRange->All]

![](img/dsp/continuous_convolution_example1.jpg)

## 连续信号的傅里叶变换和傅里叶级数 ##

连续非周期实数函数的傅里叶变换，类似DFT，有：

![](img/dsp/continuous_ft.jpg)

搞一段代码试一试：

	x[t_]=If[t<=0,0,E^(-t)];
	ReX[w_] = Integrate[ x[t]*Cos[w*t], {t, -Infinity, Infinity}];
	ImX[w_] = -Integrate[ x[t]*Sin[w*t],{t, -Infinity, Infinity}];
	
	
	xx[t_] = 1/Pi * Integrate[ ReX[w]*Cos[w*t]-ImX[w]*Sin[w*t], {w, 0, Infinity}];
	Plot[{xx[t], x[t]}, {t, -2, 3}]

结果没有问题，xx和x的曲线吻合，就是运行时间比较长。

连续周期信号展开为傅里叶级数：

![](img/dsp/continuous_fs.jpg)

# 第十四章：滤波器简介 #

这章简单介绍滤波器，后面连续7、8章都是讲滤波器，好恐怖。

滤波器通常的作用有：平滑信号、去除DC分量、去噪、分离信号中的某些频率分量等等。有模拟滤波器和数字滤波器。这里集中讲数字滤波器。

滤波器的实现，最直观的方法就是卷积，即将输入信号与一个线性系统的脉冲反应做卷积，通过设计卷积核来达到滤波器的设计与实现。

除此之外，还有一个钟设计方法是递归，大概就是把输出信号作为输入信号再次经过滤波器。这种滤波器的脉冲反应的特征是无线长度的正弦波，其幅度向右侧不断的做指数衰减。例如一个移动平均过滤器，用卷积的思想设计是：

	y[50] = (x[47] + x[48] + x[49] + x[50] + x[51] + x[52] + x[53]) / 7
	y[51] = (x[48] + x[49] + x[50] + x[51] + x[52] + x[53] + x[54]) / 7

那么用递归的思想设计是：

	y[51] = y[50] + (x[54] - x[47]) / 7

通常这样设计的滤波器运算更快。

每个线性滤波器都有脉冲反应、频率反应（前面章节提到过）、步长反应。每一个都完全体现了线性滤波器的特征。且三者有对应关系：脉冲反应的DFT就是频率反应，脉冲反应的离散积分就是步长反应，它体现的是一个单位阶跃信号经过系统后的输出。在滤波器这里有个新的名字：叫做过滤器核。

单位阶跃信号刚好也是单位脉冲信号的离散积分，这体现了线性系统卷积运算的特性：对输入信号积分和微分，经过卷积，输出结果为原输出信号的积分和微分。

![](img/dsp/step_response.jpg)

顺便提到了分贝，这个最傻逼的度量方式：

1. 分贝通常用来度量两个物理量的比值，dB=20\*Log(v1/v2)， 底数是10。 
2. 但有的地方又定义为 dB=10\*Log(v1/v2)。 20的定义更常见。
3. 有时候分贝又用来度量单个物理量的幅度或者能量，例如声音
4. 反正就是这么记忆：60dB表示1000倍，40dB表示100倍，20dB表示10倍，0dB表示1倍，-20dB表示0.1倍，-40dB表示0.01倍...

## 四种常见的滤波器 ##

四种常见的滤波器：低通滤波器、高通滤波器、带通滤波器、带阻滤波器。

![](img/dsp/four_common_filter.jpg)

前面提到过：脉冲反应可以通过在时间轴右侧补0的方式，已达到更多任意采样数的目的。采样数越多，其频率反应就越高分辨率，从而获得更精致的滤波器。而脉冲反应右侧补0不会影响卷积的正确性。

高通滤波器、带通滤波器、带阻滤波器，都可以基于低通滤波器来构造。

高通滤波器可以使用一个全通滤波器（脉冲反馈为一个单位脉冲）减去一个低通滤波器。其实前面章节也提到过这种方法。

![](img/dsp/hi_pass_filter.jpg)

带通滤波器可以通过并联低通滤波器和高通滤波器实现，两者的通过的频谱范围有叠加，：

![](img/dsp/band_pass_filter.jpg)

带阻滤波器类似的，只是低通滤波器和高通滤波器通过的频谱范围没有叠加，中间的gap就是被阻碍的带宽：

![](img/dsp/band_reject_filter.jpg)

这里只提到了滤波器的幅度的关系，那相位的要求是怎样的呢？

构造过程中，用来做加减、卷积的已知子滤波器，他们的相位必须一致，否则不能直接加减和卷积。所以要求这些子滤波器的脉冲反应都是零相位或者线性相位的信号，即都对齐某个时间点左右对称。

## 滤波器的分类 ##

![](img/dsp/filter_classification.jpg)



































